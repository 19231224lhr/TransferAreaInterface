/**
 * Private Key Encryption Module
 * 
 * Provides secure encryption/decryption for private keys using password-based encryption.
 * Uses Web Crypto API with PBKDF2 for key derivation and AES-GCM for encryption.
 * 
 * Security considerations:
 * - PBKDF2 with 100,000 iterations for key derivation
 * - Random salt for each encryption operation
 * - AES-256-GCM for authenticated encryption
 * - Random IV for each encryption
 * 
 * @module utils/keyEncryption
 */

// ========================================
// Constants
// ========================================

/** PBKDF2 iterations - higher is more secure but slower */
const PBKDF2_ITERATIONS = 100000;

/** Salt length in bytes */
const SALT_LENGTH = 16;

/** IV length in bytes for AES-GCM */
const IV_LENGTH = 12;

/** Key length in bits for AES-256 */
const KEY_LENGTH = 256;

/** Storage key for encrypted private key */
export const ENCRYPTED_KEY_STORAGE = 'encryptedPrivateKey';

/** Storage key for encryption metadata */
export const ENCRYPTION_META_STORAGE = 'encryptionMeta';

// ========================================
// Utility Functions
// ========================================

/**
 * Convert ArrayBuffer to hex string
 * @param {ArrayBuffer|Uint8Array} buffer
 * @returns {string}
 */
function bufferToHex(buffer) {
  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Convert hex string to Uint8Array
 * @param {string} hex
 * @returns {Uint8Array}
 */
function hexToBuffer(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  }
  return bytes;
}

/**
 * Convert string to Uint8Array
 * @param {string} str
 * @returns {Uint8Array}
 */
function stringToBuffer(str) {
  return new TextEncoder().encode(str);
}

/**
 * Convert Uint8Array to string
 * @param {Uint8Array} buffer
 * @returns {string}
 */
function bufferToString(buffer) {
  return new TextDecoder().decode(buffer);
}

// ========================================
// Crypto Functions
// ========================================

/**
 * Derive encryption key from password using PBKDF2
 * @param {string} password - User password
 * @param {Uint8Array} salt - Random salt
 * @returns {Promise<CryptoKey>}
 */
async function deriveKey(password, salt) {
  // Import password as key material
  const passwordBuffer = stringToBuffer(password);
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    /** @type {BufferSource} */ (passwordBuffer),
    { name: 'PBKDF2' },
    false,
    ['deriveBits', 'deriveKey']
  );

  // Derive AES key using PBKDF2
  return crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: /** @type {BufferSource} */ (salt),
      iterations: PBKDF2_ITERATIONS,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: KEY_LENGTH },
    false,
    ['encrypt', 'decrypt']
  );
}

/**
 * Encrypt private key with password
 * @param {string} privateKeyHex - Private key in hex format
 * @param {string} password - Encryption password
 * @returns {Promise<{encrypted: string, salt: string, iv: string}>}
 */
export async function encryptPrivateKey(privateKeyHex, password) {
  if (!privateKeyHex || !password) {
    throw new Error('Private key and password are required');
  }

  // Generate random salt and IV
  const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));

  // Derive key from password
  const key = await deriveKey(password, salt);

  // Encrypt the private key
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: /** @type {BufferSource} */ (iv) },
    key,
    /** @type {BufferSource} */ (stringToBuffer(privateKeyHex))
  );

  return {
    encrypted: bufferToHex(encryptedBuffer),
    salt: bufferToHex(salt),
    iv: bufferToHex(iv)
  };
}

/**
 * Decrypt private key with password
 * @param {string} encryptedHex - Encrypted data in hex format
 * @param {string} salt - Salt in hex format
 * @param {string} iv - IV in hex format
 * @param {string} password - Decryption password
 * @returns {Promise<string>} Decrypted private key in hex format
 */
export async function decryptPrivateKey(encryptedHex, salt, iv, password) {
  if (!encryptedHex || !salt || !iv || !password) {
    throw new Error('All parameters are required for decryption');
  }

  // Convert hex strings back to buffers
  const encryptedBuffer = hexToBuffer(encryptedHex);
  const saltBuffer = hexToBuffer(salt);
  const ivBuffer = hexToBuffer(iv);

  // Derive key from password
  const key = await deriveKey(password, saltBuffer);

  try {
    // Decrypt
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: /** @type {BufferSource} */ (ivBuffer) },
      key,
      /** @type {BufferSource} */ (encryptedBuffer)
    );

    return bufferToString(new Uint8Array(decryptedBuffer));
  } catch (err) {
    // Decryption failed - likely wrong password
    throw new Error('Decryption failed. Incorrect password.');
  }
}

// ========================================
// Storage Functions
// ========================================

/**
 * @typedef {Object} EncryptedKeyData
 * @property {string} encrypted - Encrypted private key
 * @property {string} salt - Encryption salt
 * @property {string} iv - Encryption IV
 * @property {number} [version] - Encryption version
 * @property {number} [timestamp] - Encryption timestamp
 */

/**
 * Save encrypted private key to localStorage
 * @param {string} accountId - Account identifier
 * @param {EncryptedKeyData} encryptedData - Encrypted key data
 */
export function saveEncryptedKey(accountId, encryptedData) {
  const key = `${ENCRYPTED_KEY_STORAGE}_${accountId}`;
  localStorage.setItem(key, JSON.stringify({
    ...encryptedData,
    version: 1,
    timestamp: Date.now()
  }));
}

/**
 * Load encrypted private key from localStorage
 * @param {string} accountId - Account identifier
 * @returns {EncryptedKeyData|null}
 */
export function loadEncryptedKey(accountId) {
  const key = `${ENCRYPTED_KEY_STORAGE}_${accountId}`;
  const data = localStorage.getItem(key);
  return data ? JSON.parse(data) : null;
}

/**
 * Remove encrypted key from storage
 * @param {string} accountId - Account identifier
 */
export function removeEncryptedKey(accountId) {
  const key = `${ENCRYPTED_KEY_STORAGE}_${accountId}`;
  localStorage.removeItem(key);
}

/**
 * Check if account has encrypted key
 * @param {string} accountId - Account identifier
 * @returns {boolean}
 */
export function hasEncryptedKey(accountId) {
  return loadEncryptedKey(accountId) !== null;
}

// ========================================
// Migration Functions
// ========================================

/**
 * Check if user has legacy (unencrypted) private key
 * @param {Object} user - User object
 * @returns {boolean}
 */
export function hasLegacyKey(user) {
  if (!user) return false;
  
  // Check for unencrypted private key in user object
  const privHex = (user.keys && user.keys.privHex) || user.privHex;
  return !!privHex && typeof privHex === 'string' && privHex.length === 64;
}

/**
 * Migrate legacy unencrypted key to encrypted storage
 * @param {Object} user - User object with legacy key
 * @param {string} password - New encryption password
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function migrateToEncrypted(user, password) {
  if (!user || !password) {
    return { success: false, error: 'User and password required' };
  }

  try {
    // Get the legacy private key
    const privHex = (user.keys && user.keys.privHex) || user.privHex;
    if (!privHex) {
      return { success: false, error: 'No private key found' };
    }

    // Encrypt the private key
    const encryptedData = await encryptPrivateKey(privHex, password);

    // Save encrypted key
    saveEncryptedKey(user.accountId, encryptedData);

    // Return success - caller should clear the plaintext key from user object
    return { success: true };
  } catch (err) {
    return { 
      success: false, 
      error: err.message || 'Migration failed' 
    };
  }
}

/**
 * Clear legacy (unencrypted) private key from user object
 * This should be called after successful migration
 * @param {Object} user - User object
 * @returns {Object} User object with cleared private key fields
 */
export function clearLegacyKey(user) {
  if (!user) return user;

  const updated = { ...user };
  
  // Clear plaintext key from keys object
  if (updated.keys) {
    updated.keys = { 
      ...updated.keys, 
      privHex: '', // Clear but keep structure
      _encrypted: true // Mark as encrypted
    };
  }
  
  // Clear legacy privHex field
  if (updated.privHex) {
    delete updated.privHex;
  }

  return updated;
}

// ========================================
// Key Access Functions
// ========================================

/**
 * Get decrypted private key (for signing operations)
 * @param {string} accountId - Account identifier
 * @param {string} password - Decryption password
 * @returns {Promise<string>} Decrypted private key hex
 */
export async function getPrivateKey(accountId, password) {
  const encryptedData = loadEncryptedKey(accountId);
  
  if (!encryptedData) {
    throw new Error('No encrypted key found for this account');
  }

  return decryptPrivateKey(
    encryptedData.encrypted,
    encryptedData.salt,
    encryptedData.iv,
    password
  );
}

/**
 * Verify password is correct for account
 * @param {string} accountId - Account identifier
 * @param {string} password - Password to verify
 * @returns {Promise<boolean>}
 */
export async function verifyPassword(accountId, password) {
  try {
    await getPrivateKey(accountId, password);
    return true;
  } catch {
    return false;
  }
}

/**
 * Change encryption password
 * @param {string} accountId - Account identifier
 * @param {string} oldPassword - Current password
 * @param {string} newPassword - New password
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function changePassword(accountId, oldPassword, newPassword) {
  try {
    // Decrypt with old password
    const privateKey = await getPrivateKey(accountId, oldPassword);

    // Re-encrypt with new password
    const encryptedData = await encryptPrivateKey(privateKey, newPassword);

    // Save new encrypted data
    saveEncryptedKey(accountId, encryptedData);

    return { success: true };
  } catch (err) {
    return { 
      success: false, 
      error: err.message || 'Password change failed' 
    };
  }
}

// ========================================
// Initialization
// ========================================

/**
 * Check encryption status and prompt for migration if needed
 * @param {Object} user - User object
 * @returns {{needsMigration: boolean, isEncrypted: boolean}}
 */
export function checkEncryptionStatus(user) {
  if (!user || !user.accountId) {
    return { needsMigration: false, isEncrypted: false };
  }

  const hasEncrypted = hasEncryptedKey(user.accountId);
  const hasLegacy = hasLegacyKey(user);

  return {
    needsMigration: hasLegacy && !hasEncrypted,
    isEncrypted: hasEncrypted
  };
}
