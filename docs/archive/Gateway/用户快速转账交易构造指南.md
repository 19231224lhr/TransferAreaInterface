# 用户快速转账交易构造指南（前端对接文档）

> 目标：前端通过 HTTP/Gateway 调用 AssignNode 的"用户提交交易"接口，在担保组织内构造并发送快速转账交易。本文档详细说明交易结构、字段含义、签名规则及验证逻辑。

---

## 接口信息

- **方法**：`POST`
- **路径**：`/api/v1/{groupID}/assign/submit-tx`
- **说明**：
  - `{groupID}` 是用户当前所属担保组织 ID
  - **用户必须已加入该担保组织**

---

## 〇、前端核心工具函数实现

> ⚠️ **重要**：以下函数是前端必须实现的核心工具函数，后续所有签名、哈希计算都依赖这些函数。

### 0.1 序列化函数（最关键）

后端使用 **JSON 序列化**，前端必须保持一致：

```typescript
/**
 * 序列化结构体（排除指定字段）
 * 后端实现：json.Marshal，排除字段设为零值后序列化
 * 
 * @param data - 要序列化的对象
 * @param excludeFields - 要排除的字段名数组（这些字段会被设为零值）
 * @returns JSON 字符串的 UTF-8 字节数组
 */
function serializeStruct(data: any, excludeFields: string[] = []): Uint8Array {
    // 1. 深拷贝对象，避免修改原对象
    const copy = JSON.parse(JSON.stringify(data));
    
    // 2. 将排除字段设为零值（不是删除，是设为零值！）
    for (const field of excludeFields) {
        if (field in copy) {
            copy[field] = getZeroValue(copy[field]);
        }
    }
    
    // 3. JSON 序列化
    const jsonStr = JSON.stringify(copy);
    
    // 4. 转为 UTF-8 字节数组
    return new TextEncoder().encode(jsonStr);
}

/**
 * 获取字段的零值（Go 语言零值规则）
 */
function getZeroValue(value: any): any {
    if (value === null || value === undefined) return null;
    if (typeof value === 'number') return 0;
    if (typeof value === 'string') return '';
    if (typeof value === 'boolean') return false;
    if (Array.isArray(value)) return [];
    if (typeof value === 'object') {
        // 对象类型：递归设置所有字段为零值
        const zero: any = {};
        for (const key of Object.keys(value)) {
            zero[key] = getZeroValue(value[key]);
        }
        return zero;
    }
    return null;
}
```

### 0.2 SHA256 哈希函数

```typescript
/**
 * 计算 SHA256 哈希
 * @param data - 字节数组
 * @returns 32字节哈希值
 */
async function sha256(data: Uint8Array): Promise<Uint8Array> {
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    return new Uint8Array(hashBuffer);
}

/**
 * 计算结构体哈希值
 * @param data - 要计算哈希的对象
 * @param excludeFields - 排除的字段
 * @returns 32字节哈希值
 */
async function getStructHash(data: any, excludeFields: string[] = []): Promise<Uint8Array> {
    const serialized = serializeStruct(data, excludeFields);
    return await sha256(serialized);
}
```

### 0.3 ECDSA P-256 签名函数

```typescript
/**
 * ECDSA P-256 签名
 * @param hash - 32字节哈希值
 * @param privateKey - CryptoKey 私钥对象
 * @returns { R: bigint, S: bigint }
 */
async function ecdsaSign(hash: Uint8Array, privateKey: CryptoKey): Promise<{ R: bigint, S: bigint }> {
    // 使用 Web Crypto API 签名
    const signature = await crypto.subtle.sign(
        { name: 'ECDSA', hash: 'SHA-256' },
        privateKey,
        hash
    );
    
    // 解析 DER 格式签名，提取 R 和 S
    const sigArray = new Uint8Array(signature);
    
    // P-256 签名是 64 字节：前 32 字节是 R，后 32 字节是 S
    const r = sigArray.slice(0, 32);
    const s = sigArray.slice(32, 64);
    
    return {
        R: bytesToBigInt(r),
        S: bytesToBigInt(s)
    };
}

/**
 * 字节数组转 BigInt
 */
function bytesToBigInt(bytes: Uint8Array): bigint {
    let hex = '0x';
    for (const b of bytes) {
        hex += b.toString(16).padStart(2, '0');
    }
    return BigInt(hex);
}

/**
 * BigInt 转字节数组（32字节，大端序）
 */
function bigIntToBytes(n: bigint, length: number = 32): Uint8Array {
    const hex = n.toString(16).padStart(length * 2, '0');
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
    }
    return bytes;
}
```

### 0.4 对结构体签名

```typescript
/**
 * 对结构体进行签名（核心函数）
 * 
 * 流程：
 * 1. 将排除字段设为零值
 * 2. JSON 序列化
 * 3. SHA256 哈希
 * 4. ECDSA 签名
 * 
 * @param data - 要签名的结构体
 * @param privateKey - 私钥
 * @param excludeFields - 不参与签名的字段
 */
async function signStruct(
    data: any, 
    privateKey: CryptoKey, 
    excludeFields: string[] = []
): Promise<{ R: bigint, S: bigint }> {
    // 1. 计算哈希（自动处理排除字段）
    const hash = await getStructHash(data, excludeFields);
    
    // 2. 签名
    return await ecdsaSign(hash, privateKey);
}
```

---

## 一、核心数据结构

> 以下同时提供 Go 后端定义和 TypeScript 前端定义，确保前后端数据结构一致。

### 1.0 前端 TypeScript 类型定义（完整）

```typescript
// ==================== 基础类型 ====================

/** ECDSA 签名 */
interface EcdsaSignature {
    R: number;  // big.Int，JSON 中为数字
    S: number;
}

/** P-256 公钥 */
interface PublicKeyNew {
    CurveName: string;  // 固定为 "P256"
    X: number;          // big.Int
    Y: number;
}

/** 交易位置 */
interface TxPosition {
    Blocknum: number;  // 区块号
    IndexX: number;    // 担保交易序号
    IndexY: number;    // 内部序号
    IndexZ: number;    // 使用哪个输出
}

// ==================== 交易输入输出 ====================

/** UTXO 输入 */
interface TXInputNormal {
    FromTXID: string;           // 来源交易ID
    FromTxPosition: TxPosition; // UTXO位置
    FromAddress: string;        // 来源地址
    IsGuarMake: boolean;        // 前端填 false
    IsCommitteeMake: boolean;   // 前端填 false
    IsCrossChain: boolean;      // 前端填 false
    TXOutputHash: number[];     // 被引用 TXOutput 的 SHA256 哈希（字节数组）
    InputSignature: EcdsaSignature;  // 地址私钥签名
}

/** 交易输出 */
interface TXOutput {
    ToAddress: string;          // 目标地址
    ToValue: number;            // 转账金额
    ToGuarGroupID: string;      // 目标担保组织ID
    ToPublicKey: PublicKeyNew;  // 目标地址公钥
    ToInterest: number;         // 分配的利息
    Type: number;               // 货币类型：0=PGC, 1=BTC, 2=ETH
    ToPeerID: string;           // 可为空字符串
    IsPayForGas: boolean;       // 是否用于支付额外Gas
    IsGuarMake: boolean;        // 前端填 false
    IsCrossChain: boolean;      // 前端填 false
}

/** 手续费分配 */
interface InterestAssign {
    Gas: number;                      // Gas费
    Output: number;                   // 转给收款方的利息
    BackAssign: Record<string, number>;  // 利息回退：address -> 比例（和为1）
}

// ==================== 交易结构 ====================

/** 交易本体 */
interface Transaction {
    TXID: string;                      // 交易ID（16字符十六进制）
    Size: number;                      // 交易大小（前端可填0）
    Version: number;                   // 版本号，填 1.0
    GuarantorGroup: string;            // 担保组织ID
    TXType: number;                    // 0=普通转账
    Value: number;                     // 总转账金额
    ValueDivision: Record<number, number>;  // 货币类型 -> 金额
    NewValue: number;                  // 前端填 0
    NewValueDiv: Record<number, number>;    // 前端填 {}
    InterestAssign: InterestAssign;
    UserSignature: EcdsaSignature;     // 前端可填 {R:0, S:0}
    TXInputsNormal: TXInputNormal[];
    TXInputsCertificate: any[];        // 快速转账填空数组
    TXOutputs: TXOutput[];
    Data: number[];                    // 前端填空数组
}

/** 用户新交易（提交给后端的顶层结构） */
interface UserNewTX {
    TX: Transaction;
    UserID: string;          // 用户8位ID
    Height: number;          // 前端填 0
    Sig: EcdsaSignature;     // 账户私钥签名
}

// ==================== 钱包数据（从 re-online 获取） ====================

/** UTXO 数据 */
interface UTXOData {
    UTXO: {
        TXID: string;
        TXOutputs: TXOutput[];
    };
    Position: TxPosition;
    Value: number;
}

/** 地址数据 */
interface SubAddressData {
    UTXO: Record<string, UTXOData>;  // utxoID -> UTXOData
    PublicKeyNew: PublicKeyNew;
    Type: number;
    Value: { TotalValue: number };
}

/** 用户钱包数据 */
interface UserWalletData {
    SubAddressMsg: Record<string, SubAddressData>;  // address -> SubAddressData
}
```

---

### 1.1 UserNewTX（提交给后端的顶层结构）

**Go 定义**：
```go
type UserNewTX struct {
    TX     Transaction    // 交易本体
    UserID string         // 用户8位ID
    Height int            // 后端填写，前端忽略
    Sig    EcdsaSignature // 使用用户账户私钥签名
}
```

| 字段 | 类型 | 必填 | 说明 |
|-----|------|-----|------|
| **TX** | Transaction | 是 | 完整的交易结构体 |
| **UserID** | string | 是 | 用户8位ID |
| **Height** | int | 否 | 后端填写，前端置0或忽略 |
| **Sig** | EcdsaSignature | 是 | **用户账户私钥**对整个 UserNewTX 签名（排除 `Sig` 和 `Height`） |

---

### 1.2 Transaction（交易本体）

```go
type Transaction struct {
    TXID           string             // 交易ID，由GetTXID()计算
    Size           int                // 交易大小，最后计算
    Version        float32            // 版本号，当前为 1.0
    GuarantorGroup string             // 担保组织ID
    TXType         int                // 交易类型：0=普通转账，1=使用TXCer
    Value          float64            // 总转账金额
    ValueDivision  map[int]float64    // 按货币类型分配金额
    
    InterestAssign InterestAssign     // 手续费分配
    UserSignature  EcdsaSignature     // 交易签名（地址私钥）
    
    TXInputsNormal      []TXInputNormal  // UTXO输入
    TXInputsCertificate []TxCertificate  // TXCer输入（快速转账可选）
    TXOutputs           []TXOutput       // 交易输出
}
```

#### 交易类型说明（TXType）

| TXType | 含义 | 说明 |
|--------|------|------|
| 0 | 普通转账 | 仅使用 UTXO 作为输入 |
| 1 | 使用 TXCer | UTXO + TXCer 混合输入 |
| -1 | 质押交易 | 本文档不涉及 |
| 6 | 跨链交易 | 本文档不涉及 |

---

### 1.3 TXInputNormal（UTXO 输入）

```go
type TXInputNormal struct {
    FromTXID       string         // 来源交易ID
    FromTxPosition TxPosition     // UTXO位置
    FromAddress    string         // 来源地址
    IsGuarMake     bool           // 前端填 false
    TXOutputHash   []byte         // 被引用UTXO的哈希值
    InputSignature EcdsaSignature // 地址私钥对 TXOutputHash 签名
}

type TxPosition struct {
    Blocknum int // 区块号
    IndexX   int // 担保交易序号
    IndexY   int // 内部序号
    IndexZ   int // 使用哪个输出
}
```

| 字段 | 说明 |
|-----|------|
| **FromTXID** | 被引用 UTXO 所在交易的 TXID |
| **FromTxPosition** | UTXO 在区块链中的精确位置 |
| **FromAddress** | 发送方地址（必须是用户自己的地址） |
| **IsGuarMake** | 前端构造时**必须填 false** |
| **TXOutputHash** | 被引用 TXOutput 的 SHA256 哈希 |
| **InputSignature** | **地址私钥**对 TXOutputHash 的 ECDSA 签名 |

---

### 1.4 TXOutput（交易输出）

```go
type TXOutput struct {
    ToAddress     string       // 目标地址
    ToValue       float64      // 转账金额
    ToGuarGroupID string       // 目标用户所属担保组织ID
    ToPublicKey   PublicKeyNew // 目标地址公钥
    ToInterest    float64      // 分配的利息
    Type          int          // 货币类型：0=PGC, 1=BTC, 2=ETH
    IsPayForGas   bool         // 是否用于支付额外Gas
    IsGuarMake    bool         // 前端填 false
    IsCrossChain  bool         // 前端填 false
}
```

---

### 1.5 InterestAssign（手续费分配）

```go
type InterestAssign struct {
    Gas        float64            // 支付给系统的Gas费
    Output     float64            // 转给收款方的利息
    BackAssign map[string]float64 // 利息回退分配：address -> 比例（加起来为1）
}
```

---

### 1.6 公钥与签名结构

```go
// 公钥
type PublicKeyNew struct {
    CurveName string   // 曲线名称，固定为 "P256"
    X         *big.Int // 公钥X坐标
    Y         *big.Int // 公钥Y坐标
}

// 签名
type EcdsaSignature struct {
    R *big.Int
    S *big.Int
}
```

**重要**：JSON 中 `X`、`Y`、`R`、`S` 必须是**数字字面量**（不带引号）。

---

## 二、签名规则详解

### 2.1 签名类型总览

| 签名位置 | 使用的私钥 | 签名内容 | 排除字段 |
|---------|-----------|---------|---------|
| `UserNewTX.Sig` | 用户**账户私钥** | 整个 UserNewTX | `Sig`, `Height` |
| `TXInputNormal.InputSignature` | **地址私钥** | 被引用 TXOutput 的哈希 | 无排除，直接对哈希签名 |

> ⚠️ **关键区分**：
> - **账户私钥**：用户加入担保组织时使用的私钥，用于身份认证
> - **地址私钥**：每个钱包子地址对应的私钥，用于证明 UTXO 所有权

---

### 2.2 TXInputNormal.InputSignature 签名流程（详细）

这是**最关键的签名**，用于证明用户有权使用该 UTXO。

**后端验证逻辑**（Go 代码）：
```go
// 后端验证：用 TXOutput.ToPublicKey 验证 InputSignature
sig := input.InputSignature
pubKey := output.ToPublicKey
hash, _ := output.GetTXOutputHash()  // JSON序列化后SHA256
result := ecdsa.Verify(&pubKey, hash, sig.R, sig.S)
```

**前端实现**：
```typescript
/**
 * 为 TXInputNormal 生成 InputSignature
 * 
 * 步骤：
 * 1. 从钱包数据中获取被引用的 TXOutput
 * 2. 对 TXOutput 进行 JSON 序列化（不排除任何字段）
 * 3. 对序列化结果计算 SHA256 哈希
 * 4. 使用该地址的私钥对哈希进行 ECDSA 签名
 */
async function createInputSignature(
    utxoData: UTXOData,           // 从钱包数据获取的 UTXO 信息
    addressPrivateKey: CryptoKey  // 该地址的私钥
): Promise<{
    TXOutputHash: number[];       // 哈希值（字节数组）
    InputSignature: { R: bigint; S: bigint };
}> {
    // 1. 获取被引用的 TXOutput
    const txOutput = utxoData.UTXO.TXOutputs[utxoData.Position.IndexZ];
    
    // 2. JSON 序列化 TXOutput（不排除任何字段）
    const serialized = serializeStruct(txOutput, []);  // 空数组=不排除
    
    // 3. 计算 SHA256 哈希
    const hash = await sha256(serialized);
    
    // 4. 使用地址私钥签名
    const signature = await ecdsaSign(hash, addressPrivateKey);
    
    return {
        TXOutputHash: Array.from(hash),  // Uint8Array 转数字数组
        InputSignature: signature
    };
}
```

---

### 2.3 UserNewTX.Sig 签名流程（详细）

**后端验证逻辑**（Go 代码）：
```go
// 后端验证：用组织内存储的用户账户公钥验证
userMsg := a.LocalMsg.GuarGroupMsg.UserMessage[txMsg.UserID]
err := core.VerifyStructSig(txMsg.Sig, core.ConvertToPublicKey(userMsg.PublicKeyNew), txMsg, "Sig", "Height")
```

**前端实现**：
```typescript
/**
 * 对 UserNewTX 进行签名
 * 
 * 步骤：
 * 1. 将 Sig 字段设为零值 { R: 0, S: 0 }
 * 2. 将 Height 字段设为零值 0
 * 3. JSON 序列化整个结构体
 * 4. 计算 SHA256 哈希
 * 5. 使用账户私钥签名
 */
async function signUserNewTX(
    userNewTX: UserNewTX,
    accountPrivateKey: CryptoKey
): Promise<{ R: bigint; S: bigint }> {
    // 1. 深拷贝，避免修改原对象
    const copy = JSON.parse(JSON.stringify(userNewTX));
    
    // 2. 将排除字段设为零值（不是删除！）
    copy.Sig = { R: 0, S: 0 };
    copy.Height = 0;
    
    // 3. JSON 序列化
    const jsonStr = JSON.stringify(copy);
    const serialized = new TextEncoder().encode(jsonStr);
    
    // 4. SHA256 哈希
    const hash = await sha256(serialized);
    
    // 5. ECDSA 签名
    return await ecdsaSign(hash, accountPrivateKey);
}
```

---

## 三、交易构造完整流程

### 3.1 前置准备

1. **获取用户钱包数据**：调用 `re-online` 接口获取 `UserWalletData`
2. **解析可用 UTXO**：从 `SubAddressMsg[address].UTXO` 中获取
3. **获取收款方信息**：收款地址、公钥、所属担保组织ID

---

### 3.2 关键函数详细实现

#### 3.2.1 计算 TXOutput 哈希（用于 InputSignature）

```typescript
/**
 * 计算 TXOutput 的哈希值
 * 后端实现：对 TXOutput 整个结构体 JSON 序列化后求 SHA256
 * 
 * ⚠️ 注意：序列化时不排除任何字段
 */
async function getTXOutputHash(txOutput: TXOutput): Promise<Uint8Array> {
    // 1. JSON 序列化（不排除任何字段）
    const serialized = serializeStruct(txOutput, []); // 无排除字段
    
    // 2. SHA256 哈希
    return await sha256(serialized);
}

/**
 * 对 TXOutput 签名（用于 TXInputNormal.InputSignature）
 * 
 * @param txOutput - 被引用的 UTXO 输出
 * @param addressPrivateKey - 该地址的私钥
 */
async function signTXOutput(
    txOutput: TXOutput, 
    addressPrivateKey: CryptoKey
): Promise<{ hash: Uint8Array, signature: { R: bigint, S: bigint } }> {
    // 1. 计算 TXOutput 哈希
    const hash = await getTXOutputHash(txOutput);
    
    // 2. 使用地址私钥签名哈希值
    const signature = await ecdsaSign(hash, addressPrivateKey);
    
    return { hash, signature };
}
```

#### 3.2.2 计算交易哈希（GetTXHash）

```typescript
/**
 * 计算交易哈希值
 * 
 * 后端实现逻辑：
 * 1. 过滤掉 IsGuarMake=true 的 Input 和 Output（前端构造的都是 false，所以不用过滤）
 * 2. 序列化时排除字段：Size, NewValue, UserSignature, TXType
 * 3. SHA256 哈希
 */
async function getTXHash(tx: Transaction): Promise<Uint8Array> {
    // 1. 过滤掉担保组织构造的 Input 和 Output（前端不用管，都是 false）
    const filteredInputs = tx.TXInputsNormal.filter(input => !input.IsGuarMake);
    const filteredOutputs = tx.TXOutputs.filter(output => !output.IsGuarMake);
    
    // 2. 创建临时交易对象（替换过滤后的数组）
    const txForHash = {
        ...tx,
        TXInputsNormal: filteredInputs,
        TXOutputs: filteredOutputs
    };
    
    // 3. 序列化（排除指定字段）
    // ⚠️ 排除字段：Size, NewValue, UserSignature, TXType
    const serialized = serializeStruct(txForHash, [
        'Size',           // 交易大小不参与
        'NewValue',       // 担保人修改后的金额不参与
        'UserSignature',  // 用户签名不参与（避免循环依赖）
        'TXType'          // 交易类型不参与
    ]);
    
    // 4. SHA256 哈希
    return await sha256(serialized);
}
```

#### 3.2.3 计算 TXID

```typescript
/**
 * 计算 TXID
 * 
 * 后端实现：取交易哈希的前8字节，转为16进制字符串
 * 结果：16个字符的十六进制字符串
 */
async function calculateTXID(tx: Transaction): Promise<string> {
    // 1. 获取交易哈希（32字节）
    const hash = await getTXHash(tx);
    
    // 2. 取前8字节
    const first8Bytes = hash.slice(0, 8);
    
    // 3. 转为十六进制字符串
    let txid = '';
    for (const byte of first8Bytes) {
        txid += byte.toString(16).padStart(2, '0');
    }
    
    return txid; // 16个字符
}
```

#### 3.2.4 对 UserNewTX 签名

```typescript
/**
 * 对 UserNewTX 结构体签名
 * 
 * 后端验证逻辑：
 * 1. 使用用户账户公钥（加入担保组织时存储的）
 * 2. 排除字段：Sig, Height
 */
async function signUserNewTX(
    userNewTX: UserNewTX, 
    accountPrivateKey: CryptoKey
): Promise<{ R: bigint, S: bigint }> {
    // 排除 Sig 和 Height 字段后签名
    return await signStruct(userNewTX, accountPrivateKey, ['Sig', 'Height']);
}
```

---

### 3.3 完整构造流程代码

```typescript
/**
 * 构造并发送快速转账交易的完整流程
 */
async function buildAndSendTransaction(params: {
    fromAddress: string;           // 发送方地址
    fromAddressPrivateKey: CryptoKey; // 发送方地址私钥
    accountPrivateKey: CryptoKey;  // 用户账户私钥
    userID: string;                // 用户ID
    groupID: string;               // 担保组织ID
    receiverAddress: string;       // 收款地址
    receiverPublicKey: PublicKeyNew; // 收款地址公钥
    receiverGroupID: string;       // 收款方担保组织ID
    transferAmount: number;        // 转账金额
    changeAddress: string;         // 找零地址
    changePublicKey: PublicKeyNew; // 找零地址公钥
    gas: number;                   // Gas费
    wallet: UserWalletData;        // 用户钱包数据（从 re-online 获取）
}) {
    const {
        fromAddress, fromAddressPrivateKey, accountPrivateKey,
        userID, groupID, receiverAddress, receiverPublicKey,
        receiverGroupID, transferAmount, changeAddress, changePublicKey,
        gas, wallet
    } = params;

    // ========== Step 1: 选择 UTXO ==========
    const selectedUTXOs: Array<{ utxoID: string; utxoData: UTXOData }> = [];
    let totalInput = 0;

    const addressUTXOs = wallet.SubAddressMsg[fromAddress]?.UTXO || {};
    for (const [utxoID, utxoData] of Object.entries(addressUTXOs)) {
        selectedUTXOs.push({ utxoID, utxoData });
        totalInput += utxoData.Value;
        if (totalInput >= transferAmount) break;
    }

    if (totalInput < transferAmount) {
        throw new Error('UTXO 余额不足');
    }

    // ========== Step 2: 构造 TXInputNormal ==========
    const txInputs: TXInputNormal[] = [];
    
    for (const { utxoData } of selectedUTXOs) {
        // 2.1 获取被引用的 TXOutput
        const txOutput = utxoData.UTXO.TXOutputs[utxoData.Position.IndexZ];
        
        // 2.2 计算 TXOutput 哈希并签名
        const { hash, signature } = await signTXOutput(txOutput, fromAddressPrivateKey);
        
        // 2.3 构造 TXInputNormal
        txInputs.push({
            FromTXID: utxoData.UTXO.TXID,
            FromTxPosition: utxoData.Position,
            FromAddress: fromAddress,
            IsGuarMake: false,        // ⚠️ 前端必须填 false
            IsCommitteeMake: false,   // ⚠️ 前端必须填 false
            IsCrossChain: false,      // ⚠️ 前端必须填 false
            TXOutputHash: Array.from(hash),  // 转为数字数组
            InputSignature: {
                R: signature.R,
                S: signature.S
            }
        });
    }

    // ========== Step 3: 构造 TXOutput ==========
    const txOutputs: TXOutput[] = [];

    // 3.1 收款输出
    txOutputs.push({
        ToAddress: receiverAddress,
        ToValue: transferAmount,
        ToGuarGroupID: receiverGroupID,
        ToPublicKey: receiverPublicKey,
        ToInterest: 0,
        Type: 0,  // 0=PGC
        ToPeerID: '',
        IsPayForGas: false,
        IsGuarMake: false,
        IsCrossChain: false
    });

    // 3.2 找零输出（如果有）
    const change = totalInput - transferAmount;
    if (change > 0) {
        txOutputs.push({
            ToAddress: changeAddress,
            ToValue: change,
            ToGuarGroupID: groupID,
            ToPublicKey: changePublicKey,
            ToInterest: 0,
            Type: 0,
            ToPeerID: '',
            IsPayForGas: false,
            IsGuarMake: false,
            IsCrossChain: false
        });
    }

    // ========== Step 4: 构造 Transaction ==========
    const transaction: Transaction = {
        TXID: '',              // Step 5 计算
        Size: 0,               // 可选，后端会重新计算
        Version: 1.0,
        GuarantorGroup: groupID,
        TXType: 0,             // 0=普通转账
        Value: transferAmount,
        ValueDivision: { 0: transferAmount },  // key 是货币类型
        NewValue: 0,           // 前端不填，后端使用
        NewValueDiv: {},       // 前端不填，后端使用
        InterestAssign: {
            Gas: gas,
            Output: 0,
            BackAssign: { [fromAddress]: 1.0 }  // 利息回退给发送地址
        },
        UserSignature: { R: BigInt(0), S: BigInt(0) },  // 可选，高安全场景使用
        TXInputsNormal: txInputs,
        TXInputsCertificate: [],   // 快速转账不使用 TXCer
        TXOutputs: txOutputs,
        Data: []
    };

    // ========== Step 5: 计算 TXID ==========
    transaction.TXID = await calculateTXID(transaction);
    console.log('计算得到 TXID:', transaction.TXID);

    // ========== Step 6: 构造 UserNewTX 并签名 ==========
    const userNewTX: UserNewTX = {
        TX: transaction,
        UserID: userID,
        Height: 0,             // 前端填 0，后端会覆盖
        Sig: { R: BigInt(0), S: BigInt(0) }  // 先置零值
    };

    // 使用账户私钥签名（排除 Sig 和 Height）
    const sig = await signUserNewTX(userNewTX, accountPrivateKey);
    userNewTX.Sig = sig;
    console.log('UserNewTX 签名完成');

    // ========== Step 7: 发送请求 ==========
    // ⚠️ 注意：BigInt 需要转为字符串或数字发送
    const requestBody = prepareForJSON(userNewTX);
    
    const response = await fetch(`/api/v1/${groupID}/assign/submit-tx`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
    });

    const result = await response.json();
    if (result.success) {
        console.log('交易提交成功，TXID:', result.tx_id);
        return result;
    } else {
        throw new Error(result.error || '交易提交失败');
    }
}

/**
 * 将 BigInt 转为 JSON 可序列化的格式
 * ⚠️ Go 后端期望 big.Int 是数字字面量
 */
function prepareForJSON(obj: any): any {
    if (obj === null || obj === undefined) return obj;
    if (typeof obj === 'bigint') {
        // 转为数字（如果在安全范围内）或字符串
        // Go 的 big.Int 可以接受 JSON number
        return Number(obj);
    }
    if (Array.isArray(obj)) {
        return obj.map(prepareForJSON);
    }
    if (typeof obj === 'object') {
        const result: any = {};
        for (const [key, value] of Object.entries(obj)) {
            result[key] = prepareForJSON(value);
        }
        return result;
    }
    return obj;
}
```

---

## 四、后端验证规则

### 4.1 基础验证

| 验证项 | 说明 |
|-------|------|
| 用户存在性 | UserID 必须在担保组织内 |
| 担保组织匹配 | TX.GuarantorGroup 必须等于当前 AssignNode 的组织ID |
| 交易类型 | TXType 只能是 0, 1, -1, 6 |

### 4.2 签名验证

| 验证项 | 说明 |
|-------|------|
| UserNewTX.Sig | 用组织内存储的用户账户公钥验证 |
| InputSignature | 用被引用 TXOutput.ToPublicKey 验证 |

### 4.3 地址验证

| 验证项 | 说明 |
|-------|------|
| 输入地址有效 | FromAddress 不能是已解绑地址 |
| 输出地址有效 | 本组织内的 ToAddress 必须存在且未解绑 |

---

## 五、响应格式

### 成功响应（HTTP 200）

```json
{
    "success": true,
    "tx_id": "a1b2c3d4e5f6g7h8"
}
```

### 失败响应

```json
{
    "error": "错误信息"
}
```

### 常见错误

| 错误信息 | 说明 |
|---------|------|
| `user is not in the guarantor group` | 用户不在担保组织内 |
| `signature verification error` | 签名验证失败 |
| `address revoked` | 使用了已解绑的地址 |
| `address not found` | 收款地址不存在 |
| `transaction type error` | 交易类型不支持 |

---

## 六、完整请求示例

```json
{
    "TX": {
        "TXID": "a1b2c3d4",
        "Size": 0,
        "Version": 1.0,
        "GuarantorGroup": "10000000",
        "TXType": 0,
        "Value": 5.0,
        "ValueDivision": { "0": 5.0 },
        "InterestAssign": {
            "Gas": 1.0,
            "Output": 0,
            "BackAssign": { "0cb3e0ee7ce34c26f2221a39bcf8df7150742d96": 1.0 }
        },
        "UserSignature": { "R": 0, "S": 0 },
        "TXInputsNormal": [
            {
                "FromTXID": "prev-tx-id",
                "FromTxPosition": { "Blocknum": 100, "IndexX": 0, "IndexY": 0, "IndexZ": 0 },
                "FromAddress": "0cb3e0ee7ce34c26f2221a39bcf8df7150742d96",
                "IsGuarMake": false,
                "TXOutputHash": [/* 32 bytes */],
                "InputSignature": {
                    "R": 12345678901234567890,
                    "S": 98765432109876543210
                }
            }
        ],
        "TXInputsCertificate": [],
        "TXOutputs": [
            {
                "ToAddress": "receiver-address",
                "ToValue": 5.0,
                "ToGuarGroupID": "10000000",
                "ToPublicKey": { "CurveName": "P256", "X": 123, "Y": 456 },
                "ToInterest": 0,
                "Type": 0,
                "IsPayForGas": false,
                "IsGuarMake": false,
                "IsCrossChain": false
            }
        ]
    },
    "UserID": "93644130",
    "Height": 0,
    "Sig": {
        "R": 11223344556677889900,
        "S": 99887766554433221100
    }
}
```

---

## 七、注意事项

1. **私钥区分**：
   - **账户私钥**：用于 `UserNewTX.Sig`（证明是该用户发起）
   - **地址私钥**：用于 `InputSignature`（证明有权使用该UTXO）

2. **序列化一致性**：前端序列化方式必须与 Go 后端一致，建议参考 `docs/gateway/前端签名与序列化唯一指南.md`

3. **big.Int 格式**：JSON 中必须是数字字面量，不能是字符串

4. **找零地址**：必须是用户自己的地址，且货币类型一致

5. **UTXO 选择**：只能使用用户自己地址下的 UTXO

6. **TXCer 使用**：快速转账时如果 UTXO 不足，可使用 TXCer（TXType=1），本文档暂不详述

---

## 八、调试建议

1. **先验证签名**：使用测试数据验证签名逻辑是否正确
2. **检查序列化**：打印序列化后的字节，对比前后端是否一致
3. **查看日志**：后端 Gateway 日志会记录详细错误信息
4. **逐步构造**：先构造最简单的单输入单输出交易

